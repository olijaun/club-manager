include "general.conf"

akka {

  //  loggers = ["akka.event.slf4j.Slf4jLogger"]
  //loggers = ["akka.event.Logging$DefaultLogger"]
  //stdout-loglevel = "OFF"
  //loglevel = "OFF"
  //  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"

  //  actor {
  //    provider = "cluster"
  //
  //    serializers {
  //      java = "akka.serialization.JavaSerializer"
  //    }
  //
  //    serialization-bindings {
  //      "java.io.Serializable" = java
  //    }
  //  }
  //  remote {
  //    log-remote-lifecycle-events = off
  //    netty.tcp {
  //      hostname = "127.0.0.1"
  //      port = 42551
  //    }
  //  }
  //
  //  cluster {
  //    seed-nodes = [
  //      "akka.tcp://mym-akka@127.0.0.1:42551",
  //      "akka.tcp://mym-akka@127.0.0.1:42552"]
  //
  //    # auto downing is NOT safe for production deployments.
  //    # you may want to use it during development, read more about it in the docs.
  //    #
  //    # auto-down-unreachable-after = 10s
  //  }

  persistence {
    journal {
      plugin = "jdbc-journal"
      // Enable the line below to automatically start the journal when the actorsystem is started
      // auto-start-journals = ["jdbc-journal"]
    }
    snapshot-store {
      plugin = "jdbc-snapshot-store"
      // Enable the line below to automatically start the snapshot-store when the actorsystem is started
      // auto-start-snapshot-stores = ["jdbc-snapshot-store"]
    }
  }
}

slick {
  driver = "slick.driver.PostgresDriver$"
  db {
    url = "jdbc:postgresql://localhost:5432/eventdb"
    user = "postgres"
    password = "password"
    driver = "org.postgresql.Driver"

    // hikariCP
    numThreads = 1 // number of cores
    maxConnections = 1 // 2 * numThreads + 1 (if running on an SSD)
    minConnections = 1  // same as numThreads

    connectionTestQuery = SELECT 1 // postgres doesnt support connection timeout
  }
}

//akka-persistence-jdbc {
//
//  database-provider-fqcn = "akka.persistence.jdbc.util.DefaultSlickDatabaseProvider"
//
//  shared-databases {
//    // Shared databases can be defined here.
//    // This reference config contains a partial example if a shared database which is enabled by configuring "slick" as the shared db
//    // this example is ignored by default as long as no profile is default
//    akkaDS {
//
//      # This property indicates which profile must be used by Slick.
//      # Possible values are: slick.jdbc.PostgresProfile$, slick.jdbc.MySQLProfile$, slick.jdbc.H2Profile$ and slick.jdbc.OracleProfile$
//      # (uncomment and set the property below to match your needs)
//      profile = "slick.jdbc.PostgresProfile$"
//
//      slick {
//
//        db {
//          connectionPool = "HikariCP"
//
//          # The JDBC URL for the chosen database
//          # (uncomment and set the property below to match your needs)
//          url = "jdbc:postgresql://localhost:5432/mydb"
//
//          # The database username
//          # (uncomment and set the property below to match your needs)
//          user = "postgres"
//
//          # The username's password
//          # (uncomment and set the property below to match your needs)
//          password = "password"
//
//          # The JDBC driver to use
//          # (uncomment and set the property below to match your needs)
//          driver = "org.postgresql.Driver"
//
//          # hikariCP settings; see: https://github.com/brettwooldridge/HikariCP
//          # Slick will use an async executor with a fixed size queue of 10.000 objects
//          # The async executor is a connection pool for asynchronous execution of blocking I/O actions.
//          # This is used for the asynchronous query execution API on top of blocking back-ends like JDBC.
//          queueSize = 10000 // number of objects that can be queued by the async exector
//
//          # This property controls the maximum number of milliseconds that a client (that's you) will wait for a connection
//          # from the pool. If this time is exceeded without a connection becoming available, a SQLException will be thrown.
//          # 1000ms is the minimum value. Default: 180000 (3 minutes)
//          connectionTimeout = 180000
//
//          # This property controls the maximum amount of time that a connection will be tested for aliveness.
//          # This value must be less than the connectionTimeout. The lowest accepted validation timeout is 1000ms (1 second). Default: 5000
//          validationTimeout = 5000
//
//          # 10 minutes: This property controls the maximum amount of time that a connection is allowed to sit idle in the pool.
//          # Whether a connection is retired as idle or not is subject to a maximum variation of +30 seconds, and average variation
//          # of +15 seconds. A connection will never be retired as idle before this timeout. A value of 0 means that idle connections
//          # are never removed from the pool. Default: 600000 (10 minutes)
//          idleTimeout = 600000
//
//          # 30 minutes: This property controls the maximum lifetime of a connection in the pool. When a connection reaches this timeout
//          # it will be retired from the pool, subject to a maximum variation of +30 seconds. An in-use connection will never be retired,
//          # only when it is closed will it then be removed. We strongly recommend setting this value, and it should be at least 30 seconds
//          # less than any database-level connection timeout. A value of 0 indicates no maximum lifetime (infinite lifetime),
//          # subject of course to the idleTimeout setting. Default: 1800000 (30 minutes)
//          maxLifetime = 1800000
//
//          # This property controls the amount of time that a connection can be out of the pool before a message is logged indicating a
//          # possible connection leak. A value of 0 means leak detection is disabled.
//          # Lowest acceptable value for enabling leak detection is 2000 (2 secs). Default: 0
//          leakDetectionThreshold = 0
//
//          # This property controls whether the pool will "fail fast" if the pool cannot be seeded with initial connections successfully.
//          # If you want your application to start even when the database is down/unavailable, set this property to false. Default: true
//          initializationFailFast = false
//
//          # ensures that the database does not get dropped while we are using it
//          keepAliveConnection = on
//
//          # See some tips on thread/connection pool sizing on https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing
//          # Keep in mind that the number of threads must equal the maximum number of connections.
//          numThreads = 20
//          maxConnections = 20
//          minConnections = 20
//        }
//      }
//    }
//  }
//}

jdbc-journal {

  slick = ${slick}
}

jdbc-snapshot-store {

  slick = ${slick}
}

# the akka-persistence-query provider in use
jdbc-read-journal {
  slick = ${slick}
}